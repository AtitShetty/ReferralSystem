package actors;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import com.fasterxml.jackson.databind.node.ObjectNode;

import akka.actor.AbstractActor;
import akka.actor.ActorRef;
import akka.actor.Props;
import akka.pattern.Patterns;
import akka.util.Timeout;
import drools.Exchanges;
import messages.AnswerMessage;
import messages.AutoGenerateQueryMessage;
import messages.CustomQueryMessage;
import messages.DumpStatesMessage;
import messages.QueryMessage;
import messages.QueryingMessage;
import messages.RefusalToAnswerMessage;
import play.libs.Json;
import referral_helper.PeerComparator;
import referral_helper.QueryGenerator;
import referral_helper.ReferralUtil;
import referral_helper.Utils;
import scala.compat.java8.FutureConverters;

public class Peer extends AbstractActor {

	private String name;

	private double[] expertise;

	private double[] needs;

	private List<Acquaintance> neighbours;

	private List<Acquaintance> acquaintances;

	public static Props getProps(String name, double[] expertise, double[] needs, List<Acquaintance> neighbours) {
		return Props.create(Peer.class, name, expertise, needs, neighbours);
	}

	public Peer(String name, double[] expertise, double[] needs, List<Acquaintance> neighbours) {
		this.name = name;
		this.expertise = expertise;
		this.needs = needs;
		this.neighbours = new LinkedList<Acquaintance>(neighbours);
		this.acquaintances = new LinkedList<Acquaintance>(neighbours);
	}

	@Override
	public Receive createReceive() {

		return receiveBuilder().match(AutoGenerateQueryMessage.class, query -> {

			ReferralUtil.logDroolsMessage(self().path().name(), !Exchanges.SEND, "AutoGenerateQuery",
					!Exchanges.TELL);

			// System.out.println("for actor" + self().path().name() + " " +
			// query.numberOfQueries);
			for (int i = 1; i <= query.numberOfQueries; i++) {
				// System.out.println("auto:" + self().path().name() + ":" + i);
				double[] randomQuery = QueryGenerator.getInstance().genQuery(this.name, needs);
				// System.out.println("Random query" +
				// Arrays.toString(randomQuery));

				askNeighbour(randomQuery);

			}
			ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, "AutoGeneratedQuery", Exchanges.TELL);
			sender().tell("Done", self());

		}).match(CustomQueryMessage.class, query -> {
			ReferralUtil.logDroolsMessage(self().path().name(), !Exchanges.SEND, Exchanges.QUERY, !Exchanges.TELL);

			ObjectNode obj = Json.newObject();

			if (Utils.isExpertiseMatch(this.expertise, query.query)) {
				obj.put("status", "success");
				obj.set("answer", Json.toJson(this.expertise));
				ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, Exchanges.ANSWER, Exchanges.TELL);
			} else {
				QueryingMessage reply = askNeighbour(query.query);

				if (reply instanceof AnswerMessage) {
					obj.put("status", "success");
					obj.set("answer", Json.toJson(((AnswerMessage) reply).answer));

					ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, Exchanges.ANSWER,
							Exchanges.TELL);
				} else {
					obj.put("status", "error");
					obj.set("message", Json.toJson(((RefusalToAnswerMessage) reply).message));
					ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, Exchanges.REFUSE_TO_ANSWER,
							Exchanges.TELL);
				}
			}

			sender().tell(obj.toString(), self());
		}).match(QueryMessage.class, query -> {
			ReferralUtil.logDroolsMessage(self().path().name(), !Exchanges.SEND, Exchanges.QUERY, !Exchanges.TELL);

			if (Utils.isExpertiseMatch(this.expertise, query.query)) {
				double[] answer = Utils.genAnswer(this.expertise, query.query);

				AnswerMessage reply = new AnswerMessage(false, answer, null);
				ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, Exchanges.ANSWER, Exchanges.TELL);

				sender().tell(reply, self());
			} else {

				LinkedList<Acquaintance> matchingNeighbours = new LinkedList<>();

				// System.out.println("Else of QueryMessage
				// ==========================>>>>");
				// System.out.println("Current actor" + self().path().name());
				// System.out.println("Sender actor" + query.parentName);
				for (Acquaintance a : this.neighbours) {
					if (!query.parentName.equals(a.name) && (Utils.isExpertiseMatch(a.expertise, query.query)
							|| Utils.isExpertiseMatch(a.sociability, query.query))) {
						a.query = query.query;
						matchingNeighbours.add(a);
					}
				}

				if (matchingNeighbours.size() == 0) {
					RefusalToAnswerMessage reply = new RefusalToAnswerMessage("No matching neighbors found");

					ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, Exchanges.REFUSE_TO_ANSWER,
							Exchanges.TELL);

					sender().tell(reply, self());
				} else {

					Collections.sort(matchingNeighbours, new PeerComparator().reversed());

					AnswerMessage reply = new AnswerMessage(true, null, matchingNeighbours.get(0).name);

					ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, Exchanges.REFERRAL,
							Exchanges.TELL);

					sender().tell(reply, self());

				}
			}

		}).match(DumpStatesMessage.class, request -> {

			ReferralUtil.logDroolsMessage(self().path().name(), !Exchanges.SEND, "GetDump", !Exchanges.TELL);

			try {
				// System.out.println(self().path());
				ObjectNode obj = Json.newObject();
				obj.put("status", "success");
				obj.set("neighbors", Json.toJson(neighbours));
				obj.set("acquaintances", Json.toJson(acquaintances));

				ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, "SendDump", Exchanges.TELL);

				sender().tell(obj.toString(), self());
			} catch (Exception e) {
				ObjectNode obj = Json.newObject();

				obj.put("status", "error");
				obj.put("message", e.getMessage());

				ReferralUtil.logDroolsMessage(self().path().name(), Exchanges.SEND, "ErrorSendingDump", Exchanges.TELL);

				sender().tell(obj.toString(), self());
			}
		}).build();
	}

	public static class Acquaintance {
		public String name;

		public double[] expertise;

		public double[] sociability;

		public double[] query;

		public Acquaintance(String name, double[] expertise, double[] sociability) {
			this.name = name;
			this.expertise = expertise;
			this.sociability = sociability;
		}

		public Acquaintance() {

		}
	}

	public QueryingMessage askNeighbour(double[] query) {

		// System.out.println("inside QueryingMessage");

		neighbours.forEach(ele -> ele.query = query);

		Collections.sort(neighbours, new PeerComparator().reversed());

		QueryingMessage reply = null;

		for (int j = 0; j < neighbours.size(); j++) {

			LinkedList<String> referralChain = new LinkedList<>();

			referralChain.add(neighbours.get(j).name);

			QueryMessage queryMessage = new QueryMessage(query, this.name);

			String currentPeer = neighbours.get(j).name;

			while (true) {

				reply = askPeer(currentPeer, queryMessage);

				if (reply instanceof AnswerMessage) {

					if (((AnswerMessage) reply).isReferral) {
						if (!referralChain.contains(((AnswerMessage) reply).referral)
								&& !(((AnswerMessage) reply).referral).equals(this.name)) {
							currentPeer = ((AnswerMessage) reply).referral;
							referralChain.add(currentPeer);
						} else {
							currentPeer = null;
							reply = new RefusalToAnswerMessage("Referral already queried");
							break;
						}
					} else {
						currentPeer = null;
						break;
					}
				} else {
					currentPeer = null;
					break;
				}
			}

			if (reply instanceof AnswerMessage) {
				double[] answer = ((AnswerMessage) reply).answer;

				addUnlistedAcquaintance(referralChain, answer, query);

			} else {
				addUnlistedAcquaintance(referralChain, null, query);
			}

			updateNeighbors();
		}

		// System.out.println("exiting QueryingMessage");
		return reply;

	}

	public QueryingMessage askPeer(String peerName, QueryingMessage query) {
		// System.out.println("inside askPeer");
		try {

			// System.out.println("ask peer" + peerName);
			ActorRef ref = FutureConverters
					.toJava(getContext().getSystem().actorSelection("user/" + peerName)
							.resolveOne(new Timeout(1, TimeUnit.MINUTES)))
					.thenApply(result -> (ActorRef) result).toCompletableFuture().get();

			QueryingMessage response = FutureConverters
					.toJava(Patterns.ask(ref, query, new Timeout(10, TimeUnit.SECONDS)))
					.thenApply(result -> (QueryingMessage) result).toCompletableFuture().get();
			// System.out.println("exiting askPeer");
			return response;
		} catch (Exception e) {
			// System.out.println("exiting askPeer");
			return new RefusalToAnswerMessage("Exception occured: " + e.getMessage());
		}

	}

	public void addUnlistedAcquaintance(LinkedList<String> peers, double[] answer, double[] query) {

		// System.out.println("inside addUnlistedAcquaintance");

		// System.out.println("size before" + acquaintances.size());
		// System.out.println("Unlisted peers are" +
		// Arrays.toString(peers.toArray()));

		List<String> notCreate = new LinkedList<>();

		for (Acquaintance a : acquaintances) {
			if (peers.contains(a.name)) {
				int depth = peers.size() - (peers.indexOf(a.name) + 1);

				updateAcquaintance(depth, a, answer, query);
				notCreate.add(a.name);
			}
		}

		// System.out.println("not create array" +
		// Arrays.toString(notCreate.toArray()));

		for (String s : peers) {
			if (!notCreate.contains(s)) {

				// System.out.println("added acquaintance" + s);
				Acquaintance a = new Acquaintance(s, getDefaultValue(0.5), getDefaultValue(0.5));

				int depth = peers.size() - (peers.indexOf(s) + 1);

				updateAcquaintance(depth, a, answer, query);

				acquaintances.add(a);
			}
		}
		// System.out.println("size after" + acquaintances.size());

		// System.out.println("exiting addUnlistedAcquaintance");
	}

	public void updateAcquaintance(int depth, Acquaintance a, double[] answer, double[] query) {

		// System.out.println("inside updateAcquaintance");
		// System.out.println("size before" + acquaintances.size());

		if (answer != null) {
			if (depth == 0) {
				// System.out.println("update expertise");
				Utils.updateExpertise(query, answer, a.expertise);
			} else {
				// System.out.println("update sociability");
				Utils.updateSociability(query, answer, depth, a.sociability);
			}
			// System.out.println("size after" + acquaintances.size());
			// System.out.println("exiting updateAcquaintance");
		}
	}

	public void updateNeighbors() {

		// System.out.println("inside updateNeighbors");
		// System.out.println("size before" + acquaintances.size());

		acquaintances.forEach(ele -> ele.query = getDefaultValue(1.0));

		Collections.sort(acquaintances, new PeerComparator().reversed());

		int maxNeighbors = Utils.getMaxNumOfNeighbors();

		neighbours.clear();

		for (int i = 0; i < Math.min(maxNeighbors, acquaintances.size()); i++) {
			neighbours.add(acquaintances.get(i));
		}
		// System.out.println("size after" + acquaintances.size());
		// System.out.println("exiting updateNeighbors");

	}

	public double[] getDefaultValue(double value) {

		// System.out.println("inside getDefaultValue");
		double[] result = this.expertise.clone();

		for (double val : result) {
			val = value;
		}

		// System.out.println("exiting getDefaultValue");

		return result.clone();
	}

}
